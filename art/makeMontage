#!/usr/bin/perl
# makeMontage - create a montage from the requested images
use strict;
use warnings;
#use Image::Magick;   # Can't get the mean through perlmagick

if ( 3 != $#ARGV ) {
    print "makeMontage <means-file> <cols> <rows> <pattern mean file>\n";
    exit;
}

my ( $meansfile, $cols, $rows, $patternname ) = @ARGV;

my $filelist;
my $tilegeom = $cols."x".$rows;
my $tile = "-tile ".$tilegeom;
my $patternfile = $patternname."-".$cols."x".$rows.".means";
my $outfile = substr( $patternfile, 0, -6 ).".gif";

# Read the means file, and sort it.
my @lines;
open my $fh, '<', $meansfile || die;
chomp(@lines = sort byFirst <$fh> );
close $fh;

# Read the pattern means file, and sort it.
my @plines;
open my $ph, '<', $patternfile || die;
chomp(@plines = sort byFirst <$ph> );
close $ph;

# Combine the two arrays, creating a new one with the location
# from the pattern and the name of the file that should go there.
my @olines;
while ( @lines && @plines ) {
    my ( $mean, $file ) =  split / /, shift @lines;
    #print "$mean - $file\n";
    my ( $pmean, $location ) = split / /, shift @plines;
    #print "$pmean - $location\n";
    push @olines, "$location $file";
}

# Sort the new array on location
my @slines = sort byFirst @olines;

# Assemble the list of files in the proper order.
while ( @slines ) {
    my ( $location, $file ) = split / /, shift @slines;
    $filelist.= "$file ";
}
#print $filelist;

my $cmd = "montage +dither $filelist $tile -mode Concatenate $outfile";
#print "calling ".$cmd."...\n";
system $cmd;

# a numeric comparison on the first word in the line
sub byFirst {
    my ( $a1 ) = split / /, $a;
    my ( $b1 ) = split / /, $b;
    $a1 <=> $b1;
}
