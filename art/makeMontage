#!/usr/bin/perl
# makeMontage - create a montage from the requested images
use strict;
use warnings;
#use Image::Magick;   # Can't get the mean through perlmagick
use List::Util qw( first );

if ( 3 != $#ARGV ) {
    print "makeMontage <means-file> <cols> <rows> <pattern mean file>\n";
    exit;
}

my ( $meansfile, $cols, $rows, $patternname ) = @ARGV;

my $filelist;
my $tilegeom = $cols."x".$rows;
my $tile = "-tile ".$tilegeom;
my $patternfile = $patternname."-".$cols."x".$rows.".means";
my $outfile = substr( $patternfile, 0, -6 ).".gif";

# Read the means file, and sort it.
my @lines;
open my $fh, '<', $meansfile || die;
chomp(@lines = sort byFirst <$fh> );
close $fh;

# Read the pattern means file.
my @plines;
open my $ph, '<', $patternfile || die;
chomp(@plines = <$ph> );
close $ph;

# For each location in the pattern, find the tile that's closest.
foreach ( @plines ) {
    my ( $m, $r, $g, $b ) = split / /, $_;   # first element is the mean tone
    my $match = first { isLighter( $m, $_ ) } @lines;  # first lighter tile
    if ( !$match ) { # if none use the lightest, ie, the last sorted one
	$match = $lines[-1];
    }
    my ( $tone, $file ) = split / /, $match; 
    $filelist.= "$file ";
}
#print $filelist;

my $cmd = "montage +dither $filelist $tile -mode Concatenate $outfile";
#print "calling ".$cmd."...\n";
system $cmd;


# a numeric comparison on the first word in the line
sub byFirst {
    my ( $a1 ) = split / /, $a;
    my ( $b1 ) = split / /, $b;
    $a1 <=> $b1;
}

sub isLighter {
    my ( $pat_mean, $tile_line ) = @_;
    my ( $tile_mean ) = split / /, $tile_line;
    #print "is ".$tile_mean." >= ".$pat_mean."?\n";
    $pat_mean < $tile_mean;
}    
